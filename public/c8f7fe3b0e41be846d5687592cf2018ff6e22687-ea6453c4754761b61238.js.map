{"version":3,"file":"c8f7fe3b0e41be846d5687592cf2018ff6e22687-ea6453c4754761b61238.js","mappings":"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","sources":["webpack://studio-prismic-starter/../../../src/lib/fmtLog.ts","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/lib/castArray.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/lib/appendFilters.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/lib/everyTagFilter.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/lib/findRef.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/lib/findMasterRef.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/lib/findRefByID.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/lib/findRefByLabel.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/lib/getPreviewCookie.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/lib/someTagsFilter.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/lib/typeFilter.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/errors/ForbiddenError.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/errors/NotFoundError.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/errors/ParsingError.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/errors/PreviewTokenExpired.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/errors/RefExpiredError.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/errors/RefNotFoundError.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/errors/RepositoryNotFoundError.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/buildQueryURL.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/createClient.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/isRepositoryEndpoint.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/getRepositoryEndpoint.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/lib/minifyGraphQLQuery.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/cookie.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/lib/castThunk.js","webpack://studio-prismic-starter/../../../src/lib/getClient.ts","webpack://studio-prismic-starter/../../../src/lib/getPluginOptions.ts","webpack://studio-prismic-starter/../../../src/lib/getRepositoryConfig.ts","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/errors/PrismicError.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/filter.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/helpers/documentToLinkField.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/helpers/asLink.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/isRepositoryName.js","webpack://studio-prismic-starter/./node_modules/@prismicio/client/dist/types/value/link.js"],"sourcesContent":["export const fmtLog = (repositoryName: string, text: string): string => {\n\treturn `gatsby-plugin-prismic-previews(${repositoryName}) - ${text}`;\n};\n","const castArray = (a) => {\n  return Array.isArray(a) ? a : [a];\n};\nexport {\n  castArray\n};\n//# sourceMappingURL=castArray.js.map\n","import { castArray } from \"./castArray.js\";\nconst appendFilters = (objWithFilters = {}, filters) => {\n  return {\n    ...objWithFilters,\n    filters: [...objWithFilters.filters || [], ...castArray(filters)]\n  };\n};\nexport {\n  appendFilters\n};\n//# sourceMappingURL=appendFilters.js.map\n","import { filter } from \"../filter.js\";\nimport { castArray } from \"./castArray.js\";\nconst everyTagFilter = (tags) => {\n  return filter.at(\"document.tags\", castArray(tags));\n};\nexport {\n  everyTagFilter\n};\n//# sourceMappingURL=everyTagFilter.js.map\n","import { PrismicError } from \"../errors/PrismicError.js\";\nconst findRef = (refs, filter) => {\n  const ref = refs.find((ref2) => filter(ref2));\n  if (!ref) {\n    throw new PrismicError(\"Ref could not be found.\", void 0, void 0);\n  }\n  return ref;\n};\nexport {\n  findRef\n};\n//# sourceMappingURL=findRef.js.map\n","import { findRef } from \"./findRef.js\";\nconst findMasterRef = (refs) => {\n  return findRef(refs, (ref) => ref.isMasterRef);\n};\nexport {\n  findMasterRef\n};\n//# sourceMappingURL=findMasterRef.js.map\n","import { findRef } from \"./findRef.js\";\nconst findRefByID = (refs, id) => {\n  return findRef(refs, (ref) => ref.id === id);\n};\nexport {\n  findRefByID\n};\n//# sourceMappingURL=findRefByID.js.map\n","import { findRef } from \"./findRef.js\";\nconst findRefByLabel = (refs, label) => {\n  return findRef(refs, (ref) => ref.label === label);\n};\nexport {\n  findRefByLabel\n};\n//# sourceMappingURL=findRefByLabel.js.map\n","import { preview } from \"../cookie.js\";\nconst readValue = (value) => {\n  return value.replace(/%3B/g, \";\");\n};\nconst getPreviewCookie = (cookieJar) => {\n  const cookies = cookieJar.split(\"; \");\n  let value;\n  for (const cookie of cookies) {\n    const parts = cookie.split(\"=\");\n    const name = readValue(parts[0]).replace(/%3D/g, \"=\");\n    if (name === preview) {\n      value = readValue(parts.slice(1).join(\"=\"));\n      break;\n    }\n  }\n  return value;\n};\nexport {\n  getPreviewCookie\n};\n//# sourceMappingURL=getPreviewCookie.js.map\n","import { filter } from \"../filter.js\";\nimport { castArray } from \"./castArray.js\";\nconst someTagsFilter = (tags) => {\n  return filter.any(\"document.tags\", castArray(tags));\n};\nexport {\n  someTagsFilter\n};\n//# sourceMappingURL=someTagsFilter.js.map\n","import { filter } from \"../filter.js\";\nconst typeFilter = (documentType) => {\n  return filter.at(\"document.type\", documentType);\n};\nexport {\n  typeFilter\n};\n//# sourceMappingURL=typeFilter.js.map\n","import { PrismicError } from \"./PrismicError.js\";\nclass ForbiddenError extends PrismicError {\n}\nexport {\n  ForbiddenError\n};\n//# sourceMappingURL=ForbiddenError.js.map\n","import { PrismicError } from \"./PrismicError.js\";\nclass NotFoundError extends PrismicError {\n}\nexport {\n  NotFoundError\n};\n//# sourceMappingURL=NotFoundError.js.map\n","import { PrismicError } from \"./PrismicError.js\";\nclass ParsingError extends PrismicError {\n}\nexport {\n  ParsingError\n};\n//# sourceMappingURL=ParsingError.js.map\n","import { ForbiddenError } from \"./ForbiddenError.js\";\nclass PreviewTokenExpiredError extends ForbiddenError {\n}\nexport {\n  PreviewTokenExpiredError\n};\n//# sourceMappingURL=PreviewTokenExpired.js.map\n","import { ForbiddenError } from \"./ForbiddenError.js\";\nclass RefExpiredError extends ForbiddenError {\n}\nexport {\n  RefExpiredError\n};\n//# sourceMappingURL=RefExpiredError.js.map\n","import { ForbiddenError } from \"./ForbiddenError.js\";\nclass RefNotFoundError extends ForbiddenError {\n}\nexport {\n  RefNotFoundError\n};\n//# sourceMappingURL=RefNotFoundError.js.map\n","import { NotFoundError } from \"./NotFoundError.js\";\nclass RepositoryNotFoundError extends NotFoundError {\n}\nexport {\n  RepositoryNotFoundError\n};\n//# sourceMappingURL=RepositoryNotFoundError.js.map\n","import { castArray } from \"./lib/castArray.js\";\nimport { devMsg } from \"./lib/devMsg.js\";\nconst RENAMED_PARAMS = {\n  accessToken: \"access_token\"\n};\nconst castOrderingToString = (ordering) => {\n  if (typeof ordering === \"string\") {\n    if (process.env.NODE_ENV === \"development\") {\n      const [field, direction] = ordering.split(\" \");\n      const objectForm = direction === \"desc\" ? `{ field: \"${field}\", direction: \"desc\" }` : `{ field: \"${field}\" }`;\n      console.warn(`[@prismicio/client] A string value was provided to the \\`orderings\\` query parameter. Strings are deprecated. Please convert it to the object form: ${objectForm}. For more details, see ${devMsg(\"orderings-must-be-an-array-of-objects\")}`);\n    }\n    return ordering;\n  }\n  return ordering.direction === \"desc\" ? `${ordering.field} desc` : ordering.field;\n};\nconst buildQueryURL = (endpoint, args) => {\n  const { filters, predicates, ...params } = args;\n  const url = new URL(`documents/search`, `${endpoint}/`);\n  if (filters) {\n    if (process.env.NODE_ENV === \"development\" && !Array.isArray(filters)) {\n      console.warn(`[@prismicio/client] A non-array value was provided to the \\`filters\\` query parameter (\\`${filters}\\`). Non-array values are deprecated. Please convert it to an array. For more details, see ${devMsg(\"filters-must-be-an-array\")}`);\n    }\n    for (const filter of castArray(filters)) {\n      url.searchParams.append(\"q\", `[${filter}]`);\n    }\n  }\n  if (predicates) {\n    for (const predicate of castArray(predicates)) {\n      url.searchParams.append(\"q\", `[${predicate}]`);\n    }\n  }\n  for (const k in params) {\n    const name = RENAMED_PARAMS[k] || k;\n    let value = params[k];\n    if (name === \"orderings\") {\n      const scopedValue = params[name];\n      if (scopedValue != null) {\n        if (process.env.NODE_ENV === \"development\" && typeof scopedValue === \"string\") {\n          console.warn(`[@prismicio/client] A string value was provided to the \\`orderings\\` query parameter. Strings are deprecated. Please convert it to an array of objects. For more details, see ${devMsg(\"orderings-must-be-an-array-of-objects\")}`);\n        }\n        const v = castArray(scopedValue).map((ordering) => castOrderingToString(ordering)).join(\",\");\n        value = `[${v}]`;\n      }\n    } else if (name === \"routes\") {\n      if (typeof params[name] === \"object\") {\n        value = JSON.stringify(castArray(params[name]));\n      }\n    }\n    if (value != null) {\n      url.searchParams.set(name, castArray(value).join(\",\"));\n    }\n  }\n  return url.toString();\n};\nexport {\n  buildQueryURL\n};\n//# sourceMappingURL=buildQueryURL.js.map\n","var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { appendFilters } from \"./lib/appendFilters.js\";\nimport { castThunk } from \"./lib/castThunk.js\";\nimport { devMsg } from \"./lib/devMsg.js\";\nimport { everyTagFilter } from \"./lib/everyTagFilter.js\";\nimport { findMasterRef } from \"./lib/findMasterRef.js\";\nimport { findRefByID } from \"./lib/findRefByID.js\";\nimport { findRefByLabel } from \"./lib/findRefByLabel.js\";\nimport { getPreviewCookie } from \"./lib/getPreviewCookie.js\";\nimport { minifyGraphQLQuery } from \"./lib/minifyGraphQLQuery.js\";\nimport { someTagsFilter } from \"./lib/someTagsFilter.js\";\nimport { typeFilter } from \"./lib/typeFilter.js\";\nimport { ForbiddenError } from \"./errors/ForbiddenError.js\";\nimport { NotFoundError } from \"./errors/NotFoundError.js\";\nimport { ParsingError } from \"./errors/ParsingError.js\";\nimport { PreviewTokenExpiredError } from \"./errors/PreviewTokenExpired.js\";\nimport { PrismicError } from \"./errors/PrismicError.js\";\nimport { RefExpiredError } from \"./errors/RefExpiredError.js\";\nimport { RefNotFoundError } from \"./errors/RefNotFoundError.js\";\nimport { RepositoryNotFoundError } from \"./errors/RepositoryNotFoundError.js\";\nimport { asLink } from \"./helpers/asLink.js\";\nimport { buildQueryURL } from \"./buildQueryURL.js\";\nimport { filter } from \"./filter.js\";\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint.js\";\nimport { getRepositoryName } from \"./getRepositoryName.js\";\nimport { isRepositoryEndpoint } from \"./isRepositoryEndpoint.js\";\nconst MAX_PAGE_SIZE = 100;\nconst REPOSITORY_CACHE_TTL = 5e3;\nconst GET_ALL_QUERY_DELAY = 500;\nconst DEFUALT_RETRY_AFTER_MS = 1e3;\nvar RefStateMode;\n(function(RefStateMode2) {\n  RefStateMode2[\"Master\"] = \"Master\";\n  RefStateMode2[\"ReleaseID\"] = \"ReleaseID\";\n  RefStateMode2[\"ReleaseLabel\"] = \"ReleaseLabel\";\n  RefStateMode2[\"Manual\"] = \"Manual\";\n})(RefStateMode || (RefStateMode = {}));\nconst createClient = (repositoryNameOrEndpoint, options) => new Client(repositoryNameOrEndpoint, options);\nclass Client {\n  /**\n   * Creates a Prismic client that can be used to query a repository.\n   *\n   * If used in an environment where a global `fetch` function is unavailable,\n   * such as Node.js, the `fetch` option must be provided as part of the\n   * `options` parameter.\n   *\n   * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n   *   API V2 endpoint for the repository.\n   * @param options - Configuration that determines how content will be queried\n   *   from the Prismic repository.\n   *\n   * @returns A client that can query content from the repository.\n   */\n  constructor(repositoryNameOrEndpoint, options = {}) {\n    /**\n     * The Prismic REST API V2 endpoint for the repository (use\n     * `prismic.getRepositoryEndpoint` for the default endpoint).\n     */\n    __publicField(this, \"endpoint\");\n    /**\n     * The secure token for accessing the API (only needed if your repository is\n     * set to private).\n     *\n     * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n     */\n    __publicField(this, \"accessToken\");\n    /**\n     * A list of route resolver objects that define how a document's `url` field\n     * is resolved.\n     *\n     * {@link https://prismic.io/docs/route-resolver}\n     */\n    __publicField(this, \"routes\");\n    /**\n     * The `brokenRoute` option allows you to define the route populated in the\n     * `url` property for broken link or content relationship fields. A broken\n     * link is a link or content relationship field whose linked document has been\n     * unpublished or deleted.\n     *\n     * {@link https://prismic.io/docs/route-resolver}\n     */\n    __publicField(this, \"brokenRoute\");\n    /**\n     * The function used to make network requests to the Prismic REST API. In\n     * environments where a global `fetch` function does not exist, such as\n     * Node.js, this function must be provided.\n     */\n    __publicField(this, \"fetchFn\");\n    __publicField(this, \"fetchOptions\");\n    /**\n     * Default parameters that will be sent with each query. These parameters can\n     * be overridden on each query if needed.\n     */\n    __publicField(this, \"defaultParams\");\n    /**\n     * The client's ref mode state. This determines which ref is used during\n     * queries.\n     */\n    __publicField(this, \"refState\", {\n      mode: RefStateMode.Master,\n      autoPreviewsEnabled: true\n    });\n    /**\n     * Cached repository value.\n     */\n    __publicField(this, \"cachedRepository\");\n    /**\n     * Timestamp at which the cached repository data is considered stale.\n     */\n    __publicField(this, \"cachedRepositoryExpiration\", 0);\n    /**\n     * Active `fetch()` jobs keyed by URL and AbortSignal (if it exists).\n     */\n    __publicField(this, \"fetchJobs\", {});\n    if (isRepositoryEndpoint(repositoryNameOrEndpoint)) {\n      if (process.env.NODE_ENV === \"development\") {\n        if (/\\.prismic\\.io\\/(?!api\\/v2\\/?)/i.test(repositoryNameOrEndpoint)) {\n          throw new PrismicError(\"@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.\", void 0, void 0);\n        }\n        const hostname = new URL(repositoryNameOrEndpoint).hostname.toLowerCase();\n        if (hostname.endsWith(\".prismic.io\") && !hostname.endsWith(\".cdn.prismic.io\")) {\n          const repositoryName = getRepositoryName(repositoryNameOrEndpoint);\n          const dotCDNEndpoint = getRepositoryEndpoint(repositoryName);\n          console.warn(`[@prismicio/client] A non-.cdn endpoint was provided to create a client with (\\`${repositoryNameOrEndpoint}\\`). Non-.cdn endpoints can have unexpected side-effects and cause performance issues when querying Prismic. Please convert it to the \\`.cdn\\` alternative (\\`${dotCDNEndpoint}\\`) or use the repository name directly instead (\\`${repositoryName}\\`). For more details, see ${devMsg(\"endpoint-must-use-cdn\")}`);\n        }\n      }\n      this.endpoint = repositoryNameOrEndpoint;\n    } else {\n      this.endpoint = getRepositoryEndpoint(repositoryNameOrEndpoint);\n    }\n    this.accessToken = options.accessToken;\n    this.routes = options.routes;\n    this.brokenRoute = options.brokenRoute;\n    this.fetchOptions = options.fetchOptions;\n    this.defaultParams = options.defaultParams;\n    if (options.ref) {\n      this.queryContentFromRef(options.ref);\n    }\n    if (typeof options.fetch === \"function\") {\n      this.fetchFn = options.fetch;\n    } else if (typeof globalThis.fetch === \"function\") {\n      this.fetchFn = globalThis.fetch;\n    } else {\n      throw new PrismicError(\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.\", void 0, void 0);\n    }\n    if (this.fetchFn === globalThis.fetch) {\n      this.fetchFn = this.fetchFn.bind(globalThis);\n    }\n    this.graphQLFetch = this.graphQLFetch.bind(this);\n  }\n  /**\n   * Enables the client to automatically query content from a preview session if\n   * one is active in browser environments. This is enabled by default in the\n   * browser.\n   *\n   * For server environments, use `enableAutoPreviewsFromReq`.\n   *\n   * @example\n   *\n   * ```ts\n   * client.enableAutoPreviews();\n   * ```\n   *\n   * @see enableAutoPreviewsFromReq\n   */\n  enableAutoPreviews() {\n    this.refState.autoPreviewsEnabled = true;\n  }\n  /**\n   * Enables the client to automatically query content from a preview session if\n   * one is active in server environments. This is disabled by default on the\n   * server.\n   *\n   * For browser environments, use `enableAutoPreviews`.\n   *\n   * @example\n   *\n   * ```ts\n   * // In an express app\n   * app.get(\"/\", function (req, res) {\n   * \tclient.enableAutoPreviewsFromReq(req);\n   * });\n   * ```\n   *\n   * @param req - An HTTP server request object containing the request's\n   *   cookies.\n   */\n  enableAutoPreviewsFromReq(req) {\n    this.refState.httpRequest = req;\n    this.refState.autoPreviewsEnabled = true;\n  }\n  /**\n   * Disables the client from automatically querying content from a preview\n   * session if one is active.\n   *\n   * Automatic preview content querying is enabled by default unless this method\n   * is called.\n   *\n   * @example\n   *\n   * ```ts\n   * client.disableAutoPreviews();\n   * ```\n   */\n  disableAutoPreviews() {\n    this.refState.autoPreviewsEnabled = false;\n  }\n  /**\n   * Queries content from the Prismic repository.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.get();\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param params - Parameters to filter, sort, and paginate results.\n   *\n   * @returns A paginated response containing the result of the query.\n   */\n  async get(params) {\n    const url = await this.buildQueryURL(params);\n    return await this.fetch(url, params);\n  }\n  /**\n   * Queries content from the Prismic repository and returns only the first\n   * result, if any.\n   *\n   * @example\n   *\n   * ```ts\n   * const document = await client.getFirst();\n   * ```\n   *\n   * @typeParam TDocument - Type of the Prismic document returned.\n   *\n   * @param params - Parameters to filter, sort, and paginate results. @returns\n   *   The first result of the query, if any.\n   */\n  async getFirst(params) {\n    var _a;\n    const actualParams = { ...params };\n    if (!(params && params.page) && !(params == null ? void 0 : params.pageSize)) {\n      actualParams.pageSize = ((_a = this.defaultParams) == null ? void 0 : _a.pageSize) ?? 1;\n    }\n    const url = await this.buildQueryURL(actualParams);\n    const result = await this.fetch(url, params);\n    const firstResult = result.results[0];\n    if (firstResult) {\n      return firstResult;\n    }\n    throw new NotFoundError(\"No documents were returned\", url, void 0);\n  }\n  /**\n   * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and\n   * require more resources than other methods. Prefer using other methods that\n   * filter by filters such as `getAllByType`.\n   *\n   * Queries content from the Prismic repository and returns all matching\n   * content. If no filters are provided, all documents will be fetched.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.dangerouslyGetAll();\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param params - Parameters to filter, sort, and paginate results.\n   *\n   * @returns A list of documents matching the query.\n   */\n  async dangerouslyGetAll(params = {}) {\n    var _a;\n    const { limit = Infinity, ...actualParams } = params;\n    const resolvedParams = {\n      ...actualParams,\n      pageSize: Math.min(limit, actualParams.pageSize || ((_a = this.defaultParams) == null ? void 0 : _a.pageSize) || MAX_PAGE_SIZE)\n    };\n    const documents = [];\n    let latestResult;\n    while ((!latestResult || latestResult.next_page) && documents.length < limit) {\n      const page = latestResult ? latestResult.page + 1 : void 0;\n      latestResult = await this.get({ ...resolvedParams, page });\n      documents.push(...latestResult.results);\n      if (latestResult.next_page) {\n        await new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY));\n      }\n    }\n    return documents.slice(0, limit);\n  }\n  /**\n   * Queries a document from the Prismic repository with a specific ID.\n   *\n   * @remarks\n   * A document's UID is different from its ID. An ID is automatically generated\n   * for all documents and is made available on its `id` property. A UID is\n   * provided in the Prismic editor and is unique among all documents of its\n   * custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n   * ```\n   *\n   * @typeParam TDocument- Type of the Prismic document returned.\n   *\n   * @param id - ID of the document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns The document with an ID matching the `id` parameter, if a matching\n   *   document exists.\n   */\n  async getByID(id, params) {\n    return await this.getFirst(appendFilters(params, filter.at(\"document.id\", id)));\n  }\n  /**\n   * Queries documents from the Prismic repository with specific IDs.\n   *\n   * @remarks\n   * A document's UID is different from its ID. An ID is automatically generated\n   * for all documents and is made available on its `id` property. A UID is\n   * provided in the Prismic editor and is unique among all documents of its\n   * custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getByIDs([\n   * \t\"WW4bKScAAMAqmluX\",\n   * \t\"U1kTRgEAAC8A5ldS\",\n   * ]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param ids - A list of document IDs.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A paginated response containing documents with IDs matching the\n   *   `ids` parameter.\n   */\n  async getByIDs(ids, params) {\n    return await this.get(appendFilters(params, filter.in(\"document.id\", ids)));\n  }\n  /**\n   * Queries all documents from the Prismic repository with specific IDs.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @remarks\n   * A document's UID is different from its ID. An ID is automatically generated\n   * for all documents and is made available on its `id` property. A UID is\n   * provided in the Prismic editor and is unique among all documents of its\n   * custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getAllByIDs([\n   * \t\"WW4bKScAAMAqmluX\",\n   * \t\"U1kTRgEAAC8A5ldS\",\n   * ]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param ids - A list of document IDs.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A list of documents with IDs matching the `ids` parameter.\n   */\n  async getAllByIDs(ids, params) {\n    return await this.dangerouslyGetAll(appendFilters(params, filter.in(\"document.id\", ids)));\n  }\n  /**\n   * Queries a document from the Prismic repository with a specific UID and\n   * custom type.\n   *\n   * @remarks\n   * A document's UID is different from its ID. An ID is automatically generated\n   * for all documents and is made available on its `id` property. A UID is\n   * provided in the Prismic editor and is unique among all documents of its\n   * custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const document = await client.getByUID(\"blog_post\", \"my-first-post\");\n   * ```\n   *\n   * @typeParam TDocument - Type of the Prismic document returned.\n   *\n   * @param documentType - The API ID of the document's custom type.\n   * @param uid - UID of the document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns The document with a UID matching the `uid` parameter, if a\n   *   matching document exists.\n   */\n  async getByUID(documentType, uid, params) {\n    return await this.getFirst(appendFilters(params, [\n      typeFilter(documentType),\n      filter.at(`my.${documentType}.uid`, uid)\n    ]));\n  }\n  /**\n   * Queries document from the Prismic repository with specific UIDs and Custom\n   * Type.\n   *\n   * @remarks\n   * A document's UID is different from its ID. An ID is automatically generated\n   * for all documents and is made available on its `id` property. A UID is\n   * provided in the Prismic editor and is unique among all documents of its\n   * custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const document = await client.getByUIDs(\"blog_post\", [\n   * \t\"my-first-post\",\n   * \t\"my-second-post\",\n   * ]);\n   * ```\n   *\n   * @typeParam TDocument - Type of the Prismic document returned.\n   *\n   * @param documentType - The API ID of the document's custom type.\n   * @param uids - A list of document UIDs.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A paginated response containing documents with UIDs matching the\n   *   `uids` parameter.\n   */\n  async getByUIDs(documentType, uids, params) {\n    return await this.get(appendFilters(params, [\n      typeFilter(documentType),\n      filter.in(`my.${documentType}.uid`, uids)\n    ]));\n  }\n  /**\n   * Queries all documents from the Prismic repository with specific UIDs and\n   * custom type.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @remarks\n   * A document's UID is different from its ID. An ID is automatically generated\n   * for all documents and is made available on its `id` property. A UID is\n   * provided in the Prismic editor and is unique among all documents of its\n   * custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getAllByUIDs([\n   * \t\"my-first-post\",\n   * \t\"my-second-post\",\n   * ]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param documentType - The API ID of the document's custom type.\n   * @param uids - A list of document UIDs.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A list of documents with UIDs matching the `uids` parameter.\n   */\n  async getAllByUIDs(documentType, uids, params) {\n    return await this.dangerouslyGetAll(appendFilters(params, [\n      typeFilter(documentType),\n      filter.in(`my.${documentType}.uid`, uids)\n    ]));\n  }\n  /**\n   * Queries a singleton document from the Prismic repository for a specific\n   * custom type.\n   *\n   * @remarks\n   * A singleton document is one that is configured in Prismic to only allow one\n   * instance. For example, a repository may be configured to contain just one\n   * Settings document. This is in contrast to a repeatable custom type which\n   * allows multiple instances of itself.\n   *\n   * @example\n   *\n   * ```ts\n   * const document = await client.getSingle(\"settings\");\n   * ```\n   *\n   * @typeParam TDocument - Type of the Prismic document returned.\n   *\n   * @param documentType - The API ID of the singleton custom type.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns The singleton document for the custom type, if a matching document\n   *   exists.\n   */\n  async getSingle(documentType, params) {\n    return await this.getFirst(appendFilters(params, typeFilter(documentType)));\n  }\n  /**\n   * Queries documents from the Prismic repository for a specific custom type.\n   *\n   * Use `getAllByType` instead if you need to query all documents for a\n   * specific custom type.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getByType(\"blog_post\");\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param documentType - The API ID of the custom type.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A paginated response containing documents of the custom type.\n   */\n  async getByType(documentType, params) {\n    return await this.get(appendFilters(params, typeFilter(documentType)));\n  }\n  /**\n   * Queries all documents from the Prismic repository for a specific Custom\n   * Type.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getByType(\"blog_post\");\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param documentType - The API ID of the custom type.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A list of all documents of the custom type.\n   */\n  async getAllByType(documentType, params) {\n    return await this.dangerouslyGetAll(appendFilters(params, typeFilter(documentType)));\n  }\n  /**\n   * Queries documents from the Prismic repository with a specific tag.\n   *\n   * Use `getAllByTag` instead if you need to query all documents with a\n   * specific tag.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getByTag(\"food\");\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param tag - The tag that must be included on a document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A paginated response containing documents with the tag.\n   */\n  async getByTag(tag, params) {\n    return await this.get(appendFilters(params, someTagsFilter(tag)));\n  }\n  /**\n   * Queries all documents from the Prismic repository with a specific tag.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getAllByTag(\"food\");\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param tag - The tag that must be included on a document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A list of all documents with the tag.\n   */\n  async getAllByTag(tag, params) {\n    return await this.dangerouslyGetAll(appendFilters(params, someTagsFilter(tag)));\n  }\n  /**\n   * Queries documents from the Prismic repository with specific tags. A\n   * document must be tagged with all of the queried tags to be included.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param tags - A list of tags that must be included on a document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A paginated response containing documents with the tags.\n   */\n  async getByEveryTag(tags, params) {\n    return await this.get(appendFilters(params, everyTagFilter(tags)));\n  }\n  /**\n   * Queries documents from the Prismic repository with specific tags. A\n   * document must be tagged with all of the queried tags to be included.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getAllByEveryTag([\"food\", \"fruit\"]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param tags - A list of tags that must be included on a document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A list of all documents with the tags.\n   */\n  async getAllByEveryTag(tags, params) {\n    return await this.dangerouslyGetAll(appendFilters(params, everyTagFilter(tags)));\n  }\n  /**\n   * Queries documents from the Prismic repository with specific tags. A\n   * document must be tagged with at least one of the queried tags to be\n   * included.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param tags - A list of tags that must be included on a document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A paginated response containing documents with at least one of the\n   *   tags.\n   */\n  async getBySomeTags(tags, params) {\n    return await this.get(appendFilters(params, someTagsFilter(tags)));\n  }\n  /**\n   * Queries documents from the Prismic repository with specific tags. A\n   * document must be tagged with at least one of the queried tags to be\n   * included.\n   *\n   * This method may make multiple network requests to query all matching\n   * content.\n   *\n   * @example\n   *\n   * ```ts\n   * const response = await client.getAllBySomeTags([\"food\", \"fruit\"]);\n   * ```\n   *\n   * @typeParam TDocument - Type of Prismic documents returned.\n   *\n   * @param tags - A list of tags that must be included on a document.\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A list of all documents with at least one of the tags.\n   */\n  async getAllBySomeTags(tags, params) {\n    return await this.dangerouslyGetAll(appendFilters(params, someTagsFilter(tags)));\n  }\n  /**\n   * Returns metadata about the Prismic repository, such as its refs, releases,\n   * and custom types.\n   *\n   * @returns Repository metadata.\n   */\n  async getRepository(params) {\n    const url = new URL(this.endpoint);\n    if (this.accessToken) {\n      url.searchParams.set(\"access_token\", this.accessToken);\n    }\n    return await this.fetch(url.toString(), params);\n  }\n  /**\n   * Returns a list of all refs for the Prismic repository.\n   *\n   * Refs are used to identify which version of the repository's content should\n   * be queried. All repositories will have at least one ref pointing to the\n   * latest published content called the \"master ref\".\n   *\n   * @returns A list of all refs for the Prismic repository.\n   */\n  async getRefs(params) {\n    const repository = await this.getRepository(params);\n    return repository.refs;\n  }\n  /**\n   * Returns a ref for the Prismic repository with a matching ID.\n   *\n   * @param id - ID of the ref.\n   *\n   * @returns The ref with a matching ID, if it exists.\n   */\n  async getRefByID(id, params) {\n    const refs = await this.getRefs(params);\n    return findRefByID(refs, id);\n  }\n  /**\n   * Returns a ref for the Prismic repository with a matching label.\n   *\n   * @param label - Label of the ref.\n   *\n   * @returns The ref with a matching label, if it exists.\n   */\n  async getRefByLabel(label, params) {\n    const refs = await this.getRefs(params);\n    return findRefByLabel(refs, label);\n  }\n  /**\n   * Returns the master ref for the Prismic repository. The master ref points to\n   * the repository's latest published content.\n   *\n   * @returns The repository's master ref.\n   */\n  async getMasterRef(params) {\n    const refs = await this.getRefs(params);\n    return findMasterRef(refs);\n  }\n  /**\n   * Returns a list of all Releases for the Prismic repository. Releases are\n   * used to group content changes before publishing.\n   *\n   * @returns A list of all Releases for the Prismic repository.\n   */\n  async getReleases(params) {\n    const refs = await this.getRefs(params);\n    return refs.filter((ref) => !ref.isMasterRef);\n  }\n  /**\n   * Returns a Release for the Prismic repository with a matching ID.\n   *\n   * @param id - ID of the Release.\n   *\n   * @returns The Release with a matching ID, if it exists.\n   */\n  async getReleaseByID(id, params) {\n    const releases = await this.getReleases(params);\n    return findRefByID(releases, id);\n  }\n  /**\n   * Returns a Release for the Prismic repository with a matching label.\n   *\n   * @param label - Label of the ref.\n   *\n   * @returns The ref with a matching label, if it exists.\n   */\n  async getReleaseByLabel(label, params) {\n    const releases = await this.getReleases(params);\n    return findRefByLabel(releases, label);\n  }\n  /**\n   * Returns a list of all tags used in the Prismic repository.\n   *\n   * @returns A list of all tags used in the repository.\n   */\n  async getTags(params) {\n    try {\n      const tagsForm = await this.getCachedRepositoryForm(\"tags\", params);\n      const url = new URL(tagsForm.action);\n      if (this.accessToken) {\n        url.searchParams.set(\"access_token\", this.accessToken);\n      }\n      return await this.fetch(url.toString(), params);\n    } catch {\n      const repository = await this.getRepository(params);\n      return repository.tags;\n    }\n  }\n  /**\n   * Builds a URL used to query content from the Prismic repository.\n   *\n   * @param params - Parameters to filter, sort, and paginate the results.\n   *\n   * @returns A URL string that can be requested to query content.\n   */\n  async buildQueryURL({ signal, fetchOptions, ...params } = {}) {\n    const ref = params.ref || await this.getResolvedRefString({ signal, fetchOptions });\n    const integrationFieldsRef = params.integrationFieldsRef || (await this.getCachedRepository({ signal, fetchOptions })).integrationFieldsRef || void 0;\n    return buildQueryURL(this.endpoint, {\n      ...this.defaultParams,\n      ...params,\n      ref,\n      integrationFieldsRef,\n      routes: params.routes || this.routes,\n      brokenRoute: params.brokenRoute || this.brokenRoute,\n      accessToken: params.accessToken || this.accessToken\n    });\n  }\n  /**\n   * Determines the URL for a previewed document during an active preview\n   * session. The result of this method should be used to redirect the user to\n   * the document's URL.\n   *\n   * @example\n   *\n   * ```ts\n   * \tconst url = client.resolvePreviewURL({\n   * \tlinkResolver: (document) => `/${document.uid}`\n   * \tdefaultURL: '/'\n   * \t})\n   * ```\n   *\n   * @param args - Arguments to configure the URL resolving.\n   *\n   * @returns The URL for the previewed document during an active preview\n   *   session. The user should be redirected to this URL.\n   */\n  async resolvePreviewURL(args) {\n    var _a, _b;\n    let documentID = args.documentID;\n    let previewToken = args.previewToken;\n    if (typeof globalThis.location !== \"undefined\") {\n      const searchParams = new URLSearchParams(globalThis.location.search);\n      documentID = documentID || searchParams.get(\"documentId\");\n      previewToken = previewToken || searchParams.get(\"token\");\n    } else if (this.refState.httpRequest) {\n      if (\"query\" in this.refState.httpRequest) {\n        documentID = documentID || ((_a = this.refState.httpRequest.query) == null ? void 0 : _a.documentId);\n        previewToken = previewToken || ((_b = this.refState.httpRequest.query) == null ? void 0 : _b.token);\n      } else if (\"url\" in this.refState.httpRequest && this.refState.httpRequest.url) {\n        const searchParams = new URL(this.refState.httpRequest.url, \"missing-host://\").searchParams;\n        documentID = documentID || searchParams.get(\"documentId\");\n        previewToken = previewToken || searchParams.get(\"token\");\n      }\n    }\n    if (documentID != null && previewToken != null) {\n      const document = await this.getByID(documentID, {\n        ref: previewToken,\n        lang: \"*\",\n        signal: args.signal,\n        fetchOptions: args.fetchOptions\n      });\n      const url = asLink(document, { linkResolver: args.linkResolver });\n      if (typeof url === \"string\") {\n        return url;\n      }\n    }\n    return args.defaultURL;\n  }\n  /**\n   * Configures the client to query the latest published content for all future\n   * queries.\n   *\n   * If the `ref` parameter is provided during a query, it takes priority for\n   * that query.\n   *\n   * @example\n   *\n   * ```ts\n   * await client.queryLatestContent();\n   * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n   * ```\n   */\n  queryLatestContent() {\n    this.refState.mode = RefStateMode.Master;\n  }\n  /**\n   * Configures the client to query content from a specific Release identified\n   * by its ID for all future queries.\n   *\n   * If the `ref` parameter is provided during a query, it takes priority for\n   * that query.\n   *\n   * @example\n   *\n   * ```ts\n   * await client.queryContentFromReleaseByID(\"YLB7OBAAACMA7Cpa\");\n   * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n   * ```\n   *\n   * @param releaseID - The ID of the Release.\n   */\n  queryContentFromReleaseByID(releaseID) {\n    this.refState = {\n      ...this.refState,\n      mode: RefStateMode.ReleaseID,\n      releaseID\n    };\n  }\n  /**\n   * Configures the client to query content from a specific Release identified\n   * by its label for all future queries.\n   *\n   * If the `ref` parameter is provided during a query, it takes priority for\n   * that query.\n   *\n   * @example\n   *\n   * ```ts\n   * await client.queryContentFromReleaseByLabel(\"My Release\");\n   * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n   * ```\n   *\n   * @param releaseLabel - The label of the Release.\n   */\n  queryContentFromReleaseByLabel(releaseLabel) {\n    this.refState = {\n      ...this.refState,\n      mode: RefStateMode.ReleaseLabel,\n      releaseLabel\n    };\n  }\n  /**\n   * Configures the client to query content from a specific ref. The ref can be\n   * provided as a string or a function.\n   *\n   * If a function is provided, the ref is fetched lazily before each query. The\n   * function may also be asynchronous.\n   *\n   * @example\n   *\n   * ```ts\n   * await client.queryContentFromRef(\"my-ref\");\n   * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n   * ```\n   *\n   * @param ref - The ref or a function that returns the ref from which to query\n   *   content.\n   */\n  queryContentFromRef(ref) {\n    this.refState = {\n      ...this.refState,\n      mode: RefStateMode.Manual,\n      ref\n    };\n  }\n  /**\n   * A `fetch()` function to be used with GraphQL clients configured for\n   * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`\n   * and Authorization headers. Queries will automatically be minified by\n   * removing whitespace where possible.\n   *\n   * @example\n   *\n   * ```ts\n   * const graphQLClient = new ApolloClient({\n   * \tlink: new HttpLink({\n   * \t\turi: prismic.getGraphQLEndpoint(repositoryName),\n   * \t\t// Provide `client.graphQLFetch` as the fetch implementation.\n   * \t\tfetch: client.graphQLFetch,\n   * \t\t// Using GET is required.\n   * \t\tuseGETForQueries: true,\n   * \t}),\n   * \tcache: new InMemoryCache(),\n   * });\n   * ```\n   *\n   * @param input - The `fetch()` `input` parameter. Only strings are supported.\n   * @param init - The `fetch()` `init` parameter. Only plain objects are\n   *   supported.\n   *\n   * @returns The `fetch()` Response for the request.\n   *\n   * @experimental\n   */\n  async graphQLFetch(input, init) {\n    const cachedRepository = await this.getCachedRepository();\n    const ref = await this.getResolvedRefString();\n    const unsanitizedHeaders = {\n      \"Prismic-ref\": ref,\n      Authorization: this.accessToken ? `Token ${this.accessToken}` : \"\",\n      // Asserting `init.headers` is a Record since popular GraphQL\n      // libraries pass this as a Record. Header objects as input\n      // are unsupported.\n      ...init ? init.headers : {}\n    };\n    if (cachedRepository.integrationFieldsRef) {\n      unsanitizedHeaders[\"Prismic-integration-field-ref\"] = cachedRepository.integrationFieldsRef;\n    }\n    const headers = {};\n    for (const key in unsanitizedHeaders) {\n      if (unsanitizedHeaders[key]) {\n        headers[key.toLowerCase()] = unsanitizedHeaders[key];\n      }\n    }\n    const url = new URL(\n      // Asserting `input` is a string since popular GraphQL\n      // libraries pass this as a string. Request objects as\n      // input are unsupported.\n      input\n    );\n    url.searchParams.set(\"ref\", ref);\n    const query = url.searchParams.get(\"query\");\n    if (query) {\n      url.searchParams.set(\n        \"query\",\n        // Compress the GraphQL query (if it exists) by\n        // removing whitespace. This is done to\n        // optimize the query size and avoid\n        // hitting the upper limit of GET requests\n        // (2048 characters).\n        minifyGraphQLQuery(query)\n      );\n    }\n    return await this.fetchFn(url.toString(), {\n      ...init,\n      headers\n    });\n  }\n  /**\n   * Returns a cached version of `getRepository` with a TTL.\n   *\n   * @returns Cached repository metadata.\n   */\n  async getCachedRepository(params) {\n    if (!this.cachedRepository || Date.now() >= this.cachedRepositoryExpiration) {\n      this.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;\n      this.cachedRepository = await this.getRepository(params);\n    }\n    return this.cachedRepository;\n  }\n  /**\n   * Returns a cached Prismic repository form. Forms are used to determine API\n   * endpoints for types of repository data.\n   *\n   * @param name - Name of the form.\n   *\n   * @returns The repository form.\n   *\n   * @throws If a matching form cannot be found.\n   */\n  async getCachedRepositoryForm(name, params) {\n    const cachedRepository = await this.getCachedRepository(params);\n    const form = cachedRepository.forms[name];\n    if (!form) {\n      throw new PrismicError(`Form with name \"${name}\" could not be found`, void 0, void 0);\n    }\n    return form;\n  }\n  /**\n   * Returns the ref needed to query based on the client's current state. This\n   * method may make a network request to fetch a ref or resolve the user's ref\n   * thunk.\n   *\n   * If auto previews are enabled, the preview ref takes priority if available.\n   *\n   * The following strategies are used depending on the client's state:\n   *\n   * - If the user called `queryLatestContent`: Use the repository's master ref.\n   *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is\n   *   fetched.\n   * - If the user called `queryContentFromReleaseByID`: Use the release's ref.\n   *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n   *   release is fetched.\n   * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.\n   *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n   *   release is fetched.\n   * - If the user called `queryContentFromRef`: Use the provided ref. Fall back\n   *   to the master ref if the ref is not a string.\n   *\n   * @returns The ref to use during a query.\n   */\n  async getResolvedRefString(params) {\n    var _a, _b;\n    if (this.refState.autoPreviewsEnabled) {\n      let previewRef;\n      let cookieJar;\n      if ((_a = this.refState.httpRequest) == null ? void 0 : _a.headers) {\n        if (\"get\" in this.refState.httpRequest.headers && typeof this.refState.httpRequest.headers.get === \"function\") {\n          cookieJar = this.refState.httpRequest.headers.get(\"cookie\");\n        } else if (\"cookie\" in this.refState.httpRequest.headers) {\n          cookieJar = this.refState.httpRequest.headers.cookie;\n        }\n      } else if ((_b = globalThis.document) == null ? void 0 : _b.cookie) {\n        cookieJar = globalThis.document.cookie;\n      }\n      if (cookieJar) {\n        previewRef = getPreviewCookie(cookieJar);\n      }\n      if (previewRef) {\n        return previewRef;\n      }\n    }\n    const cachedRepository = await this.getCachedRepository(params);\n    const refModeType = this.refState.mode;\n    if (refModeType === RefStateMode.ReleaseID) {\n      return findRefByID(cachedRepository.refs, this.refState.releaseID).ref;\n    } else if (refModeType === RefStateMode.ReleaseLabel) {\n      return findRefByLabel(cachedRepository.refs, this.refState.releaseLabel).ref;\n    } else if (refModeType === RefStateMode.Manual) {\n      const res = await castThunk(this.refState.ref)();\n      if (typeof res === \"string\") {\n        return res;\n      }\n    }\n    return findMasterRef(cachedRepository.refs).ref;\n  }\n  /**\n   * Performs a network request using the configured `fetch` function. It\n   * assumes all successful responses will have a JSON content type. It also\n   * normalizes unsuccessful network requests.\n   *\n   * @typeParam T - The JSON response.\n   *\n   * @param url - URL to the resource to fetch.\n   * @param params - Prismic REST API parameters for the network request.\n   *\n   * @returns The JSON response from the network request.\n   */\n  async fetch(url, params = {}) {\n    var _a, _b, _c, _d;\n    const requestInit = {\n      ...this.fetchOptions,\n      ...params.fetchOptions,\n      headers: {\n        ...(_a = this.fetchOptions) == null ? void 0 : _a.headers,\n        ...(_b = params.fetchOptions) == null ? void 0 : _b.headers\n      },\n      signal: ((_c = params.fetchOptions) == null ? void 0 : _c.signal) || params.signal || ((_d = this.fetchOptions) == null ? void 0 : _d.signal)\n    };\n    let job;\n    if (this.fetchJobs[url] && this.fetchJobs[url].has(requestInit.signal)) {\n      job = this.fetchJobs[url].get(requestInit.signal);\n    } else {\n      this.fetchJobs[url] = this.fetchJobs[url] || /* @__PURE__ */ new Map();\n      job = this.fetchFn(url, requestInit).then(async (res2) => {\n        let json = void 0;\n        try {\n          json = await res2.json();\n        } catch {\n        }\n        return {\n          status: res2.status,\n          headers: res2.headers,\n          json\n        };\n      }).finally(() => {\n        this.fetchJobs[url].delete(requestInit.signal);\n        if (this.fetchJobs[url].size === 0) {\n          delete this.fetchJobs[url];\n        }\n      });\n      this.fetchJobs[url].set(requestInit.signal, job);\n    }\n    const res = await job;\n    if (res.status !== 404 && res.json == null) {\n      throw new PrismicError(void 0, url, res.json);\n    }\n    switch (res.status) {\n      case 200: {\n        return res.json;\n      }\n      case 400: {\n        throw new ParsingError(res.json.message, url, res.json);\n      }\n      case 401:\n      case 403: {\n        throw new ForbiddenError(res.json.error || res.json.message, url, res.json);\n      }\n      case 404: {\n        if (res.json === void 0) {\n          throw new RepositoryNotFoundError(`Prismic repository not found. Check that \"${this.endpoint}\" is pointing to the correct repository.`, url, void 0);\n        }\n        if (res.json.type === \"api_notfound_error\") {\n          throw new RefNotFoundError(res.json.message, url, res.json);\n        }\n        if (res.json.type === \"api_security_error\" && /preview token.*expired/i.test(res.json.message)) {\n          throw new PreviewTokenExpiredError(res.json.message, url, res.json);\n        }\n        throw new NotFoundError(res.json.message, url, res.json);\n      }\n      case 410: {\n        throw new RefExpiredError(res.json.message, url, res.json);\n      }\n      case 429: {\n        const parsedRetryAfter = Number(res.headers.get(\"retry-after\"));\n        const delay = Number.isNaN(parsedRetryAfter) ? DEFUALT_RETRY_AFTER_MS : parsedRetryAfter;\n        return await new Promise((resolve, reject) => {\n          setTimeout(async () => {\n            try {\n              resolve(await this.fetch(url, params));\n            } catch (error) {\n              reject(error);\n            }\n          }, delay);\n        });\n      }\n    }\n    throw new PrismicError(void 0, url, res.json);\n  }\n}\nexport {\n  Client,\n  GET_ALL_QUERY_DELAY,\n  REPOSITORY_CACHE_TTL,\n  createClient\n};\n//# sourceMappingURL=createClient.js.map\n","const isRepositoryEndpoint = (input) => {\n  try {\n    new URL(input);\n    return true;\n  } catch {\n    return false;\n  }\n};\nexport {\n  isRepositoryEndpoint\n};\n//# sourceMappingURL=isRepositoryEndpoint.js.map\n","import { PrismicError } from \"./errors/PrismicError.js\";\nimport { isRepositoryName } from \"./isRepositoryName.js\";\nconst getRepositoryEndpoint = (repositoryName) => {\n  if (isRepositoryName(repositoryName)) {\n    return `https://${repositoryName}.cdn.prismic.io/api/v2`;\n  } else {\n    throw new PrismicError(`An invalid Prismic repository name was given: ${repositoryName}`, void 0, void 0);\n  }\n};\nexport {\n  getRepositoryEndpoint\n};\n//# sourceMappingURL=getRepositoryEndpoint.js.map\n","const minifyGraphQLQuery = (query) => {\n  return query.replace(/(\\n| )*( |{|})(\\n| )*/gm, (_chars, _spaces, brackets) => brackets);\n};\nexport {\n  minifyGraphQLQuery\n};\n//# sourceMappingURL=minifyGraphQLQuery.js.map\n","const preview = \"io.prismic.preview\";\nexport {\n  preview\n};\n//# sourceMappingURL=cookie.js.map\n","const castThunk = (a) => {\n  return typeof a === \"function\" ? a : () => a;\n};\nexport {\n  castThunk\n};\n//# sourceMappingURL=castThunk.js.map\n","import type { Client } from \"@prismicio/client\";\nimport { createClient as baseCreateClient } from \"@prismicio/client\";\n\nimport type { PluginOptions } from \"../types\";\n\nimport { usePrismicPreviewStore } from \"../usePrismicPreviewStore\";\n\nexport const getClient = (pluginOptions: PluginOptions): Client => {\n\tconst state = usePrismicPreviewStore.getState();\n\n\tif (state.client) {\n\t\treturn state.client;\n\t} else {\n\t\tconst client = baseCreateClient(\n\t\t\tpluginOptions.apiEndpoint || pluginOptions.repositoryName,\n\t\t\t{\n\t\t\t\taccessToken: pluginOptions.accessToken,\n\t\t\t\troutes: pluginOptions.routes,\n\t\t\t\tdefaultParams: {\n\t\t\t\t\tlang: pluginOptions.lang || \"*\",\n\t\t\t\t\tfetchLinks: pluginOptions.fetchLinks,\n\t\t\t\t\tgraphQuery: pluginOptions.graphQuery,\n\t\t\t\t\tpredicates: pluginOptions.predicates,\n\t\t\t\t},\n\t\t\t},\n\t\t);\n\n\t\tstate.setClient(client);\n\n\t\treturn client;\n\t}\n};\n","import type { PluginOptions } from \"../types\";\n\nimport { usePrismicPreviewStore } from \"../usePrismicPreviewStore\";\n\nexport const getPluginOptions = (\n\trepositoryName: string,\n): PluginOptions | undefined => {\n\tconst state = usePrismicPreviewStore.getState();\n\n\treturn state.pluginOptions[repositoryName];\n};\n","import type { RepositoryConfig } from \"../types\";\n\nimport { usePrismicPreviewStore } from \"../usePrismicPreviewStore\";\n\nexport const getRepositoryConfig = (\n\trepositoryName: string,\n): RepositoryConfig | undefined => {\n\tconst state = usePrismicPreviewStore.getState();\n\n\treturn state.repositoryConfigs.find(\n\t\t(config) => config.repositoryName === repositoryName,\n\t);\n};\n","var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass PrismicError extends Error {\n  constructor(message = \"An invalid API response was returned\", url, response) {\n    super(message);\n    __publicField(this, \"url\");\n    __publicField(this, \"response\");\n    this.url = url;\n    this.response = response;\n  }\n}\nexport {\n  PrismicError\n};\n//# sourceMappingURL=PrismicError.js.map\n","const formatValue = (value) => {\n  if (Array.isArray(value)) {\n    return `[${value.map(formatValue).join(\", \")}]`;\n  }\n  if (typeof value === \"string\") {\n    return `\"${value}\"`;\n  }\n  if (value instanceof Date) {\n    return `${value.getTime()}`;\n  }\n  return `${value}`;\n};\nconst pathWithArgsFilter = (name) => {\n  const fn = (path, ...args) => {\n    const formattedArgs = args.map(formatValue).join(\", \");\n    const joiner = path && args.length ? \", \" : \"\";\n    return `[${name}(${path}${joiner}${formattedArgs})]`;\n  };\n  return fn;\n};\nconst pathFilter = (name) => {\n  const filterFn = pathWithArgsFilter(name);\n  const fn = (path) => {\n    return filterFn(path);\n  };\n  return fn;\n};\nconst argsFilter = (name) => {\n  const filterFn = pathWithArgsFilter(name);\n  const fn = (...args) => {\n    return filterFn(\"\", ...args);\n  };\n  return fn;\n};\nconst filter = {\n  /**\n   * The `at` filter checks that the path matches the described value exactly.\n   * It takes a single value for a field or an array (only for tags).\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#at}\n   */\n  at: pathWithArgsFilter(\"at\"),\n  /**\n   * The `not` filter checks that the path doesn't match the provided value\n   * exactly. It takes a single value for a field or an array (only for tags).\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#not}\n   */\n  not: pathWithArgsFilter(\"not\"),\n  /**\n   * The `any` filter takes an array of values. It works exactly the same way as\n   * the `at` operator, but checks whether the fragment matches any of the\n   * values in the array.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#any}\n   */\n  any: pathWithArgsFilter(\"any\"),\n  /**\n   * The `in` filter is used specifically to retrieve an array of documents by\n   * their IDs or UIDs. This filter is much more efficient at this than the any\n   * filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#in}\n   */\n  in: pathWithArgsFilter(\"in\"),\n  /**\n   * The `fulltext` filter provides two capabilities:\n   *\n   * 1. Checking if a certain string is anywhere inside a document (this is what\n   *    you should use to make your project's search engine feature)\n   * 2. Checking if the string is contained inside a specific custom types Rich\n   *    Text or Key Text fragment.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#fulltext}\n   */\n  fulltext: pathWithArgsFilter(\"fulltext\"),\n  /**\n   * The `has` filter checks whether a fragment has a value. It will return all\n   * the documents of the specified type that contain a value for the specified\n   * field.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#has}\n   */\n  has: pathFilter(\"has\"),\n  /**\n   * The `missing` filter checks if a fragment doesn't have a value. It will\n   * return all the documents of the specified type that do not contain a value\n   * for the specified field.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#missing}\n   */\n  missing: pathFilter(\"missing\"),\n  /**\n   * The `similar` filter takes the ID of a document, and returns a list of\n   * documents with similar content. This allows you to build an automated\n   * content discovery feature (for example, a \"Related posts\" section).\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#similar}\n   */\n  similar: argsFilter(\"similar\"),\n  /**\n   * The `geopoint.near` filter checks that the value in the path is within the\n   * radius of the given coordinates.\n   *\n   * This filter will only work for a geopoint field.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#geopointnear}\n   */\n  geopointNear: pathWithArgsFilter(\"geopoint.near\"),\n  /**\n   * The `number.lt` filter checks that the value in the number field is less\n   * than the value passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#numberlessthan}\n   */\n  numberLessThan: pathWithArgsFilter(\"number.lt\"),\n  /**\n   * The `number.gt` filter checks that the value in the number field is greater\n   * than the value passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#numbergreaterthan}\n   */\n  numberGreaterThan: pathWithArgsFilter(\"number.gt\"),\n  /**\n   * The `number.inRange` filter checks that the value in the path is within the\n   * two values passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#numberinrange}\n   */\n  numberInRange: pathWithArgsFilter(\"number.inRange\"),\n  /**\n   * The `date.after` filter checks that the value in the path is after the date\n   * value passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateAfter: pathWithArgsFilter(\"date.after\"),\n  /**\n   * The `date.before` filter checks that the value in the path is before the\n   * date value passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateBefore: pathWithArgsFilter(\"date.before\"),\n  /**\n   * The `date.between` filter checks that the value in the path is within the\n   * date values passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateBetween: pathWithArgsFilter(\"date.between\"),\n  /**\n   * The `date.day-of-month` filter checks that the value in the path is equal\n   * to the day of the month passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateDayOfMonth: pathWithArgsFilter(\"date.day-of-month\"),\n  /**\n   * The `date.day-of-month-after` filter checks that the value in the path is\n   * after the day of the month passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateDayOfMonthAfter: pathWithArgsFilter(\"date.day-of-month-after\"),\n  /**\n   * The `date.day-of-month-before` filter checks that the value in the path is\n   * before the day of the month passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateDayOfMonthBefore: pathWithArgsFilter(\"date.day-of-month-before\"),\n  /**\n   * The `date.day-of-week` filter checks that the value in the path is equal to\n   * the day of the week passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateDayOfWeek: pathWithArgsFilter(\"date.day-of-week\"),\n  /**\n   * The `date.day-of-week-after` filter checks that the value in the path is\n   * after the day of the week passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateDayOfWeekAfter: pathWithArgsFilter(\"date.day-of-week-after\"),\n  /**\n   * The date.day-of-week-before filter checks that the value in the path is\n   * before the day of the week passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateDayOfWeekBefore: pathWithArgsFilter(\"date.day-of-week-before\"),\n  /**\n   * The `date.month` filter checks that the value in the path occurs in the\n   * month value passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateMonth: pathWithArgsFilter(\"date.month\"),\n  /**\n   * The `date.month-after` filter checks that the value in the path occurs in\n   * any month after the value passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateMonthAfter: pathWithArgsFilter(\"date.month-after\"),\n  /**\n   * The `date.month-before` filter checks that the value in the path occurs in\n   * any month before the value passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateMonthBefore: pathWithArgsFilter(\"date.month-before\"),\n  /**\n   * The `date.year` filter checks that the value in the path occurs in the year\n   * value passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateYear: pathWithArgsFilter(\"date.year\"),\n  /**\n   * The `date.hour` filter checks that the value in the path occurs within the\n   * hour value passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateHour: pathWithArgsFilter(\"date.hour\"),\n  /**\n   * The `date.hour-after` filter checks that the value in the path occurs after\n   * the hour value passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateHourAfter: pathWithArgsFilter(\"date.hour-after\"),\n  /**\n   * The `date.hour-before` filter checks that the value in the path occurs\n   * before the hour value passed into the filter.\n   *\n   * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n   */\n  dateHourBefore: pathWithArgsFilter(\"date.hour-before\")\n};\nexport {\n  filter\n};\n//# sourceMappingURL=filter.js.map\n","import { LinkType } from \"../types/value/link.js\";\nconst documentToLinkField = (prismicDocument) => {\n  var _a;\n  return {\n    link_type: LinkType.Document,\n    id: prismicDocument.id,\n    uid: prismicDocument.uid || void 0,\n    type: prismicDocument.type,\n    tags: prismicDocument.tags,\n    lang: prismicDocument.lang,\n    url: prismicDocument.url == null ? void 0 : prismicDocument.url,\n    slug: (_a = prismicDocument.slugs) == null ? void 0 : _a[0],\n    // The REST API does not include a `data` property if the data\n    // object is empty.\n    //\n    // A presence check for `prismicDocument.data` is done to\n    // support partial documents. While `documentToLinkField` is\n    // not typed to accept partial documents, passing a partial\n    // document can happen in untyped projects.\n    ...prismicDocument.data && Object.keys(prismicDocument.data).length > 0 ? { data: prismicDocument.data } : {}\n  };\n};\nexport {\n  documentToLinkField\n};\n//# sourceMappingURL=documentToLinkField.js.map\n","import { LinkType } from \"../types/value/link.js\";\nimport { documentToLinkField } from \"./documentToLinkField.js\";\nconst asLink = (linkFieldOrDocument, ...configObjectOrTuple) => {\n  if (!linkFieldOrDocument) {\n    return null;\n  }\n  const linkField = (\n    // prettier-ignore\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore - Bug in TypeScript 4.9: https://github.com/microsoft/TypeScript/issues/51501\n    // TODO: Remove the `prettier-ignore` comment when this bug is fixed.\n    \"link_type\" in linkFieldOrDocument ? linkFieldOrDocument : documentToLinkField(linkFieldOrDocument)\n  );\n  const [configObjectOrLinkResolver] = configObjectOrTuple;\n  let config;\n  if (typeof configObjectOrLinkResolver === \"function\" || configObjectOrLinkResolver == null) {\n    config = {\n      linkResolver: configObjectOrLinkResolver\n    };\n  } else {\n    config = { ...configObjectOrLinkResolver };\n  }\n  switch (linkField.link_type) {\n    case LinkType.Media:\n    case LinkType.Web:\n      return \"url\" in linkField ? linkField.url : null;\n    case LinkType.Document: {\n      if (\"id\" in linkField && config.linkResolver) {\n        const resolvedURL = config.linkResolver(linkField);\n        if (resolvedURL != null) {\n          return resolvedURL;\n        }\n      }\n      if (\"url\" in linkField && linkField.url) {\n        return linkField.url;\n      }\n      return null;\n    }\n    case LinkType.Any:\n    default:\n      return null;\n  }\n};\nexport {\n  asLink\n};\n//# sourceMappingURL=asLink.js.map\n","const isRepositoryName = (input) => {\n  return /^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(input);\n};\nexport {\n  isRepositoryName\n};\n//# sourceMappingURL=isRepositoryName.js.map\n","const LinkType = {\n  Any: \"Any\",\n  Document: \"Document\",\n  Media: \"Media\",\n  Web: \"Web\"\n};\nexport {\n  LinkType\n};\n//# sourceMappingURL=link.js.map\n"],"names":["fmtLog","repositoryName","text","castArray","a","Array","isArray","appendFilters","objWithFilters","filters","everyTagFilter","tags","filter","at","findRef","refs","ref","find","ref2","PrismicError","findMasterRef","isMasterRef","findRefByID","id","findRefByLabel","label","readValue","value","replace","someTagsFilter","any","typeFilter","documentType","ForbiddenError","NotFoundError","ParsingError","PreviewTokenExpiredError","RefExpiredError","RefNotFoundError","RepositoryNotFoundError","RENAMED_PARAMS","accessToken","castOrderingToString","ordering","direction","field","__defProp","Object","defineProperty","__publicField","obj","key","enumerable","configurable","writable","__defNormalProp","RefStateMode","RefStateMode2","Client","constructor","repositoryNameOrEndpoint","options","this","mode","Master","autoPreviewsEnabled","input","URL","isRepositoryEndpoint","endpoint","isRepositoryName","getRepositoryEndpoint","routes","brokenRoute","fetchOptions","defaultParams","queryContentFromRef","fetch","fetchFn","globalThis","bind","graphQLFetch","enableAutoPreviews","refState","enableAutoPreviewsFromReq","req","httpRequest","disableAutoPreviews","get","params","url","buildQueryURL","getFirst","_a","actualParams","page","pageSize","firstResult","results","dangerouslyGetAll","limit","Infinity","resolvedParams","Math","min","documents","latestResult","next_page","length","push","Promise","res","setTimeout","slice","getByID","getByIDs","ids","in","getAllByIDs","getByUID","uid","getByUIDs","uids","getAllByUIDs","getSingle","getByType","getAllByType","getByTag","tag","getAllByTag","getByEveryTag","getAllByEveryTag","getBySomeTags","getAllBySomeTags","getRepository","searchParams","set","toString","getRefs","getRefByID","getRefByLabel","getMasterRef","getReleases","getReleaseByID","releases","getReleaseByLabel","getTags","tagsForm","getCachedRepositoryForm","action","signal","getResolvedRefString","integrationFieldsRef","getCachedRepository","args","predicates","append","predicate","k","name","scopedValue","map","join","JSON","stringify","resolvePreviewURL","_b","documentID","previewToken","location","URLSearchParams","search","query","documentId","token","document","lang","asLink","linkResolver","defaultURL","queryLatestContent","queryContentFromReleaseByID","releaseID","ReleaseID","queryContentFromReleaseByLabel","releaseLabel","ReleaseLabel","Manual","init","cachedRepository","unsanitizedHeaders","Authorization","headers","toLowerCase","_chars","_spaces","brackets","minifyGraphQLQuery","Date","now","cachedRepositoryExpiration","form","forms","previewRef","cookieJar","cookie","cookies","split","parts","getPreviewCookie","refModeType","_c","_d","requestInit","job","fetchJobs","has","Map","then","async","res2","json","status","finally","delete","size","message","error","type","test","parsedRetryAfter","Number","delay","isNaN","resolve","reject","getClient","pluginOptions","state","usePrismicPreviewStore","getState","client","apiEndpoint","fetchLinks","graphQuery","setClient","getPluginOptions","getRepositoryConfig","repositoryConfigs","config","Error","response","super","formatValue","getTime","pathWithArgsFilter","path","formattedArgs","joiner","pathFilter","filterFn","not","fulltext","missing","similar","argsFilter","geopointNear","numberLessThan","numberGreaterThan","numberInRange","dateAfter","dateBefore","dateBetween","dateDayOfMonth","dateDayOfMonthAfter","dateDayOfMonthBefore","dateDayOfWeek","dateDayOfWeekAfter","dateDayOfWeekBefore","dateMonth","dateMonthAfter","dateMonthBefore","dateYear","dateHour","dateHourAfter","dateHourBefore","linkFieldOrDocument","configObjectOrTuple","linkField","prismicDocument","link_type","Document","slug","slugs","data","keys","configObjectOrLinkResolver","Media","Web","resolvedURL","Any","LinkType"],"sourceRoot":""}